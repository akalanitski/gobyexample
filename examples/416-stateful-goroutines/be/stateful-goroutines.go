// У папярэднім прыкладзе мы выкарыстоўвалі відавочную блакіроўку з дапамогай
// [м'ютэксаў](mutexes) для сінхранізацыі доступу да агульнага стану
// паміж некалькімі горуцінамі. Іншы варыянт - выкарыстоўваць
// убудаваныя функцыі сінхранізацыі горуцін і
// каналаў для дасягнення таго ж выніку. Гэты падыход, заснаваны на каналах,
// адпавядае ідэям Go аб сумесным выкарыстанні памяці шляхам
// абмену інфармацыяй і належання кожнай часткі дадзеных
// роўна адной горуцінам.

package main

import (
	"fmt"
	"math/rand"
	"sync/atomic"
	"time"
)

// У гэтым прыкладзе наш стан будзе належаць адной
// горуціне. Гэта гарантуе, што дадзеныя ніколі не будуць
// пашкоджаныя пры адначасовым доступе. Каб прачытаць або
// запісаць гэты стан, іншыя горуціны будуць адпраўляць паведамленні
// у горуціне-ўладальніку і атрымліваць адпаведныя
// адказы. Гэтыя структуры `readOp` і `writeOp`
// інкапсулююць гэтыя запыты і спосаб для горуціны-ўладальніка адказаць.
type readOp struct {
	key  int
	resp chan int
}
type writeOp struct {
	key  int
	val  int
	resp chan bool
}

func main() {

	// Як і раней, мы будзем лічыць, колькі аперацый мы выконваем.
	var readOps uint64
	var writeOps uint64

	// Каналы `reads` і `wires` будуць выкарыстоўвацца
	// іншымі горуцінамі для выканання запытаў на чытанне і запіс,
	// адпаведна.
	reads := make(chan readOp)
	writes := make(chan writeOp)

	// Тут гаруціна, якая валодае `станам`, які
	// з'яўляецца мапай, як у папярэднім прыкладзе, але цяпер прыватным
	// для гаруціны з захаваннем стану. Гэта гаруціна паўторна
	// выбірае з каналаў `чытання` і `запісу`,
	// адказваючы на запыты па меры іх паступлення. Адказ
	// выконваецца шляхам спачатку выканання запытанай
	// аперацыі, а затым адпраўкі значэння на канале адказу
	// `resp`, каб паказаць поспех (і жаданае
	// значэнне ў выпадку `чытання`).
	go func() {
		var state = make(map[int]int)
		for {
			select {
			case read := <-reads:
				read.resp <- state[read.key]
			case write := <-writes:
				state[write.key] = write.val
				write.resp <- true
			}
		}
	}()

	// Тут запускаецца 100 горуцін для выдачы чытанняў у
	// горуціну, якая валодае станам, праз канал `reads`.
	// Кожнае чытанне патрабуе стварэння `readOp`, адпраўкі
	// яе праз канал `reads`, а затым атрымання
	// выніку праз прадастаўлены канал `resp`.
	for r := 0; r < 100; r++ {
		go func() {
			for {
				read := readOp{
					key:  rand.Intn(5),
					resp: make(chan int)}
				reads <- read
				<-read.resp
				atomic.AddUint64(&readOps, 1)
				time.Sleep(time.Millisecond)
			}
		}()
	}

	// Мы таксама запускаем 10 "пісацелей", выкарыстоўваючы падобны
	// падыход.
	for w := 0; w < 10; w++ {
		go func() {
			for {
				write := writeOp{
					key:  rand.Intn(5),
					val:  rand.Intn(100),
					resp: make(chan bool)}
				writes <- write
				<-write.resp
				atomic.AddUint64(&writeOps, 1)
				time.Sleep(time.Millisecond)
			}
		}()
	}

	// Дайце горуцінам папрацаваць секунду.
	time.Sleep(time.Second)

	// Нарэшце, зафіксаваць і паведаміць пра колькасць аперацый.
	readOpsFinal := atomic.LoadUint64(&readOps)
	fmt.Println("readOps:", readOpsFinal)
	writeOpsFinal := atomic.LoadUint64(&writeOps)
	fmt.Println("writeOps:", writeOpsFinal)
}
