// Каб чакаць завяршэння некалькіх горуцін, можна
// выкарыстоўваць *WaitGroup*.

package main

import (
	"fmt"
	"sync"
	"time"
)

// Гэта функцыя, якую мы будзем выконваць у кожнай горуціне.
func worker(id int) {
	fmt.Printf("Worker %d starting\n", id)

	// Сон для імітацыі цяжкай працы.
	time.Sleep(time.Second)
	fmt.Printf("Worker %d done\n", id)
}

func main() {

	// Гэтая група чакання выкарыстоўваецца для чакання завяршэння ўсіх
	// запушчаных горуцін. Заўвага: калі група чакання
	// яўна перадаецца ў функцыі, гэта павінна рабіцца *па ўказальніку*.
	var wg sync.WaitGroup

	// Запусціць некалькі горуцін і павялічыць лічыльнік WaitGroup для кожнай з іх.
	for i := 1; i <= 5; i++ {
		wg.Add(1)

		// Абгарніце выклік функцыі `worker` замыканнем, якое паведаміць
		// групе WaitGroup, што выклік функцыі завершаны. Такім чынам, функцыі
		// не трэба ведаць пра канкаренсі.
		go func() {
			defer wg.Done()
			worker(i)
		}()
	}

	// Чакаць, пакуль лічыльнік WaitGroup не вернецца да 0;
	// то бок усе функцыі выканаюцца і адзначацца ў `WaitGroup`.
	wg.Wait()

	// Звярніце ўвагу, што гэты падыход не мае простага спосабу
	// певедаміць пра памылкі пад час выканання канкаренсі-функцыі. Для
	// складаных выпадкаў варта завярнуцца да
	// [пакета errgroup](https://pkg.go.dev/golang.org/x/sync/errgroup).
}
