// Часам нам патрэбна, каб нашы праграмы Go інтэлектуальна
// апрацоўвалі [сігналы Unix](https://en.wikipedia.org/wiki/Unix_signal).
// Напрыклад, нам патрэбна, каб сервер карэктна
// завяршаўся, калі атрымлівае `SIGTERM`, або каб інструмент з тэкставым інтэрфейсам
// спыніў апрацоўку ўваходных дадзеных, калі атрымлівае `SIGINT`.
// Вось як апрацоўваць сігналы ў Go з каналамі.

package main

import (
	"fmt"
	"os"
	"os/signal"
	"syscall"
)

func main() {

	// Апавяшчэнне сігналу Go працуе шляхам адпраўкі значэнняў `os.Signal`
	// у канал. Мы створым канал для атрымання гэтых апавяшчэнняў.
	// Звярніце ўвагу, што гэты канал павінен быць буферызаваны.
	sigs := make(chan os.Signal, 1)

	// `signal.Notify` рэгіструе дадзены канал для
	// атрымання апавяшчэнняў аб указаных сігналах.
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

	// Мы маглі б атрымліваць ад `sigs` тут, у галоўнай функцыі
	// але давайце паглядзім, як гэта можна зрабіць
	// у асобнай горуціне, каб паказаць больш рэалістычны
	// сцэнар карэктнага завяршэння працы.
	done := make(chan bool, 1)

	go func() {
		// Гэтая горуціна выконвае блакіруючы прыём для
		// сігналаў. Калі атрымлівае сігнал, яна яго выводзіць
		// і затым паведамляе праграме, што яна можа завяршыць працу.
		sig := <-sigs
		fmt.Println()
		fmt.Println(sig)
		done <- true
	}()

	// Праграма будзе чакаць тут, пакуль не атрымае сігнал
	// (як паказана ў горуціне вышэй, адпраўка значэння пасля `done`),
	// а затым выйдзе з праграмы.
	fmt.Println("awaiting signal")
	<-done
	fmt.Println("exiting")
}
