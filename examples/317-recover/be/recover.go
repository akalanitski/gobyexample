// Go дазваляе _аднаўляцца_ пасля панікі, выкарыстоўваючы
// ўбудаваную функцыю `recover`. `recover` можа
// спыніць `panic` ад перапынення праграмы і дазволіць ёй
// працягваць выкананне.

// Прыклад таго, дзе гэта можа быць карысным: сервер
// не хацеў бы ляснуцца, калі на адным з кліенцкіх злучэнняў
// адбудзецца крытычная памылка. Замест гэтага сервер
// закрые злучэнне з такім кліентам і працягне абслугоўванне
// іншых. Фактычна, гэта тое, што `net/http` у Go
// робіць па змаўчанні для HTTP-сервераў.

package main

import "fmt"

// Гэтая функцыя выклікае паніку.
func mayPanic() {
	panic("a problem")
}

func main() {
	// `recover` павінна быць выклікана ўнутры адкладзенай функцыі.
	// Калі функцыя, якая яе ахоплівае, панікуе, defer будзе
	// актываваны, і выклік `recover` унутры яе перахапіць
	// паніку.
	defer func() {
		if r := recover(); r != nil {
			// Вяртанае значэнне `recover` — гэта памылка, узнікшая пры
			// выкліку `panic`.
			fmt.Println("Recovered. Error:\n", r)
		}
	}()

	mayPanic()

	// Гэты код не будзе выкананы, бо `mayPanic` выклікае паніку.
	// Выкананне `main` спыняецца ў пункце
	// панікі і аднаўляецца ў адкладзеным замыканні.
	fmt.Println("After mayPanic()")
}
