// _Закрыццё_ канала азначае, што ў яго больш не будзе адпраўлена
// значэнняў. Гэта карысна для паведамлення завяршэнне прыёму для
// прыёмніка

package main

import "fmt"

// У гэтым прыкладзе мы будзем выкарыстоўваць канал `jobs` для
// паведамляецца аб працы, якую трэба выканаць, з дапамогай горуціны `main()`
// да рабочай горуціны. Калі ў нас больш няма працы
// работнік, для якога мы `закрыем` канал `jobs`.
func main() {
	jobs := make(chan int, 5)
	done := make(chan bool)

	// Тут горуціна, атрымлівае з каналу `jobs` рэзультат у дзьзве
	// пераменных `j, more := <-jobs`. Першая атрымлівае значэнне
	// адпраўленнае ў кнала, другая стан звязку. `more` будзе `false`,
	// калі канал `jobs` закрыецца.
	// Так можна паведаміць пра тое што новых значэнь у канал больш
	// не будзе адпраўлена.
	go func() {
		for {
			j, more := <-jobs
			if more {
				fmt.Println("received job", j)
			} else {
				fmt.Println("received all jobs")
				done <- true
				return
			}
		}
	}()

	// Тут адпраўляецца 3 тры лічбы у канал а затым
	// выводзіць гэтыя лічбы
	for j := 1; j <= 3; j++ {
		jobs <- j
		fmt.Println("sent job", j)
	}
	close(jobs)
	fmt.Println("sent all jobs")

	// Чкакаем завяршэння горуціны выкарыстоўваючы
	// [synchronization](channel-synchronization)
	// падыхо, які мы бачылі раней
	<-done

	// Чытанне з закрытага канала неадкладна (сінхронна)
	// павяртае рэзультат. Вяртае нулявое значэнне базавага тыпу.
	// Неабавязковае другое значэнне — `true`, калі
	// атрыманае значэнне было дастаўлена паспяховай аперацыяй адпраўкі
	// у канал, або `false`, калі гэта было
	// нулявое значэнне, згенераванае з-за таго, што канал закрыты
	// і пусты.
	_, ok := <-jobs
	fmt.Println("received more jobs:", ok)
}
