// У [папярэднім прыкладзе](range-over-built-in-types) мы ўбачылі, як `for` і
// `range` забяспечваюць ітэрацыю па базавых структурах дадзеных.
// Мы таксама можам выкарыстоўваць гэты сінтаксіс для ітэрацыі па
// значэннях, атрыманых з канала.

package main

import "fmt"

func main() {

	// Мы перабярэм 2 значэнні ў канале `queue`.
	queue := make(chan string, 2)
	queue <- "one"
	queue <- "two"
	close(queue)

	// Гэты `дыяпазон` перабірае кожны элемент па меры яго атрымання
	// з заргі (`queue`). Паколькі мы закрылі
	// канал вышэй (`close`), ітэрацыя завяршаецца пасля
	// атрымання 2 элементаў.
	for elem := range queue {
		fmt.Println(elem)
	}
}
