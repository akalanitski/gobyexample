// Go прапануе ўбудаваную падтрымку [рэгулярных выразаў](https://en.wikipedia.org/wiki/Regular_expression).
// Вось некалькі прыкладаў распаўсюджаных задач, звязаных з рэгулярнымі выразамі
// ў Go.

package main

import (
	"bytes"
	"fmt"
	"regexp"
)

func main() {

	// Тутт правяраецца, ці адпавядае тэкст шаблону.
	match, _ := regexp.MatchString("p([a-z]+)ch", "peach")
	fmt.Println(match)

	// Вышэй мы выкарыстоўвалі шаблон непасрэдна, але для
	// іншых задач з рэгулярнымі выразамі трэба будзе `кампіляваць`
	// аптымізаваную структуру `Regexp`.
	r, _ := regexp.Compile("p([a-z]+)ch")

	// Для гэтых структур даступна шмат метадаў. Вось
	// праверка на супадзенне, як мы бачылі раней.
	fmt.Println(r.MatchString("peach"))

	// Тут знаходзіць супадзенне для рэгулярнага выразу.
	fmt.Println(r.FindString("peach punch"))

	// Тут таксама знаходзіць першае супадзенне, але вяртае
	// пачатковы і канчатковы індэксы супадзення замест
	// адпаведнага тэксту.
	fmt.Println("idx:", r.FindStringIndex("peach punch"))

	// Варыянты `Submatch` утрымліваюць інфармацыю пра
	// супадзенні па ўсім шаблоне, так і падсупадзенні
	// унутры гэтых супадзенняў. Напрыклад, гэта верне
	// інфармацыю пра `p([a-z]+)ch` і `([a-z]+)`.
	fmt.Println(r.FindStringSubmatch("peach punch"))

	// Падобным чынам тут вернецца інфармацыю пра
	// індэксы супадзенняў і падсупадзенняў.
	fmt.Println(r.FindStringSubmatchIndex("peach punch"))

	// Функцыя `FindAllString` прымяняюцца да ўсіх
	// супадзенняў у ўваходных дадзеных, а не толькі да першага. Напрыклад,
	// знайсці ўсе супадзенні для рэгулярнага выразу.
	fmt.Println(r.FindAllString("peach punch pinch", -1))

	// Тут уве варыянты даступныя і для іншых
	// функцый, якія мы разглядалі вышэй.
	fmt.Println("all:", r.FindAllStringSubmatchIndex(
		"peach punch pinch", -1))

	// Задача неадмоўнага цэлага ліку ў якасці другога
	// аргумента гэтых функцый абмяжуе колькасць
	// супадзенняў.
	fmt.Println(r.FindAllString("peach punch pinch", 2))

	// У нашых прыкладах вышэй былі тэкставыя аргументы і выкарыстоўваліся
	// назвы тыпу `MatchString`. Мы таксама можам даць
	// аргументы тыпу `[]byte` і выдаліць `String` з
	// назвы функцыі.
	fmt.Println(r.Match([]byte("peach")))

	// Пры стварэнні глабальных зменных з дапамогай рэгулярных
	// выразаў можна выкарыстоўваць варыяцыю `MustCompile`
	// `Compile`. `MustCompile` выклікае паніку замест таго, каб
	// вяртаць памылку, што робіць яго больш бяспечным для выкарыстання для
	// глабальных зменных.
	r = regexp.MustCompile("p([a-z]+)ch")
	fmt.Println("regexp:", r)

	// Пакет `regexp` таксама можна выкарыстоўваць для замены
	// падмностваў радкоў іншымі значэннямі.
	fmt.Println(r.ReplaceAllString("a peach", "<fruit>"))

	// Варыянт `Func` дазваляе пераўтвараць адпаведны
	// тэкст з дапамогай зададзенай функцыі.
	in := []byte("a peach")
	out := r.ReplaceAllFunc(in, bytes.ToUpper)
	fmt.Println(string(out))
}
