// _Тайм-аўты_ важныя для праграм, якія падключаюцца да
// знешніх рэсурсаў або якім неабходна абмежаваць
// час выканання. Рэалізацыя тайм-аўтаў у Go простая і
// элегантная дзякуючы каналам і `select`.

package main

import (
	"fmt"
	"time"
)

func main() {

	// Для нашага прыкладу, дапусцім, што мы выконваем знешні
	// выклік, які вяртае вынік у канал `c1`
	// праз 2 секунды. Звярніце ўвагу, што канал буферызуецца, таму
	// адпраўка ў горуціну не прыпыняе праграму. Гэта
	// распаўсюджаны шаблон для прадухілення ўцечак горуцін ў выпадку, калі
	// канал ніколі не будзе прачытаны.
	c1 := make(chan string, 1)
	go func() {
		time.Sleep(2 * time.Second)
		c1 <- "result 1"
	}()

	// Тут `select`, які рэалізуе тайм-аўт.
	// `res := <-c1` чакае выніку а `<-time.After`
	// чакае тайм-аўту
	// Паколькі `select` працуе з першым значэннем якое ён атрымае
	// У нашым прыкгладзе гэта будзе значэнне тайм-аўту
	select {
	case res := <-c1:
		fmt.Println(res)
	case <-time.After(1 * time.Second):
		fmt.Println("timeout 1")
	}

	// Калі мы дазволім большы тайм-аўт, роўны 3 секундам, то атрыманне
	// ад `c2` будзе паспяховым, і мы вывядзем вынік.
	c2 := make(chan string, 1)
	go func() {
		time.Sleep(2 * time.Second)
		c2 <- "result 2"
	}()
	select {
	case res := <-c2:
		fmt.Println(res)
	case <-time.After(3 * time.Second):
		fmt.Println("timeout 2")
	}
}
